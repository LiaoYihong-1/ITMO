1. Технология JavaServer Faces. Особенности, отличия от сервлетов и JSP, преимущества и недостатки. Структура JSF-приложения.

   Фрейворк для разработки веб-приложений. Java EE. Основан на использовании конпонентов

   JSF更加完备的MVC，更加安全

   - 恢復視圖：從JSF收到請求開始

   - 應用請求值：在回發請求期間恢復組件樹

   - 處理驗證：處理在組件樹上註冊的所有驗證器

   - 更新模型值：遍歷組件樹並設置相應的服務器端對象屬性

   - 調用應用程序：處理應用程序級事件，例如提交表單

   - 渲染響應：構建視圖並渲染頁

   - 2. 渲染阶段

     在此阶段，请求的视图作为对客户端浏览器的响应。 视图渲染是以HTML或XHTML生成输出的过程。 所以，用户可以在浏览器看到它。

     在渲染过程中采取以下步骤。

     - 当客户端对`index.xhtml`网页进行初始请求时，编译应用程序。
     - 应用程序在编译后执行，并为应用程序构建一个新的组件树，并放置在FacesContext中。
     - 使用由`EL`表达式表示的组件和与其关联受托管`bean`属性填充组件树。
     - 基于组件树。 建立了新的视图。
     - 该视图作为响应呈现给请求客户端。
     - 组件树被自动销毁。
     - 在后续请求中，重新构建组件树，并应用已保存的状态

2. Использование JSP-страниц и Facelets-шаблонов в JSF-приложениях.

   JSP的优点：
   1）可平衡现有的JSP应用；
   2）很多极好的IDE均支持JSP。

    

   Facelets的优点：
   1）在性能和可伸缩性方面大大改进；
   2）快速地模板/装饰功能，支持页面重用；
   3）精确地定位错误报告；
   4）完整支持EL表达式。

   5） 省略了写很多标签

3. JSF-компоненты - особенности реализации, иерархия классов. Дополнительные библиотеки компонентов. Модель обработки событий в JSF-приложениях.

**Особенности реализации:**

- Интерфейс строится из компонентов.
- Компоненты расположены на страницах JSP.
- Компоненты реализуют интерфейс javax.faces.component.UIComponent.
- Можно создавать собственные компоненты.
- Компоненты на странице объединены в древовидную структуру — представление.
- Корневым элементов представления является экземпляр класса javax.faces.component.UIViewRoot.
- **Иерархия классов (фрагмент)**
  1. javax.faces.component.UIComponent
     1. javax.faces.component.UIComponentBase
        1. javax.faces.component.UIOutput
           1. javax.faces.component.UIInput
              1. javax.faces.component.UISelectOne
              2. javax.faces.component.UISelectMany

Жизненный цикл обработки запроса в приложениях JSF состоит из следующих фаз:

Восстановление представления

Использование параметров запроса; обработка событий

Проверка данных; обработка событий

Обновление данных модели; обработка событий

Вызов приложения; обработка событий

Вывод результата



4. Конвертеры и валидаторы данных.

   Конвертеры данных в JSF

   Конвертация – это процесс преобразования данных к нужным типам. В процессе конвертации строковые поля форм преобразуются в даты (класс Date), примитивные типы float, в объекты типа Float и т.д. JSF позволяет использовать как встроенные, так и специально созданные для данного приложения конвертеры. Вначале мы расскажем об использовании стандартных конвертеров JSF, а затем подробно рассмотрим создание специализированных конвертеров.

   Стандартные конвертеры JSF

   В стандартную поставку JSF входит множество стандартных конвертеров данных, благодаря чему большая часть конвертации происходит автоматически. В таблице 1 приведены идентификаторы стандартных конвертеров и реализующие их классы. Они используются в JSF для преобразования строк к простым типам.

​	**Валидаторы в JSF**

​	Главной целью конвертации и валидации является подготовка данных для обновления объектов модели. Таким образом, к моменту вызова методов, реализующих логику приложения, можно сделать определенные выводы о состоянии модели. Конвертация и валидация позволяют сконцентрироваться на бизнес-логике приложения, а не на утомительных проверках ввода, таких как проверка на null, на длину, на границы массивов и т.д.



5. **Представление страницы JSF на стороне сервера. Класс UIViewRoot.**

   UI Component. Объект с состоянием, методами, событиями, который содержится на сервере и отвечает за взаимодействие с пользователем. По сути, это визуальный компонент. Самое главное, что каждый UI компонент содержит метод для прорисовки самого себя — метод render. Render прорисовывает себя согласно правилам. Какие правила могут быть? Правила задаются следующим классом — Renderer

   +Renderer - Отвечает за отображение компонента и преобразование ввода пользователя. То есть когда срабатывает предыдущий метод render, он обращается к Renderer и говорит: «рисуй, вот тебе мои данные, рисуй».

6. равляемые бины - назначение, способы конфигурации. Контекст управляемых бинов.

   ***Управляемые бины*** – классы, содержащие параметры и методы для обработки данных с компонентов. Имеют набор методов get и set для получения/установки свойств. Используются для обработки UI и валидации данных. ЖЦ управляет JSF Runtime Env. Доступ из JSP-страниц осуществляется с помощью языка выражений (EL). Конфигурация задается либо в faces-config.xml, либо с помощью аннотаций.

   +Managed bean - это обычный Java бин, который зарегистрирован в JSF и управляется JSF платформой. В JSF *managed bean* используются в качестве модели для компонентов и имеют свою область жизни (*scope*), которую можно задать, как при помощи аннотации, так и в конфигурационном файле *faces-config.xm*

   **@SessionScoped** - инстанс создаётся один раз при обращении пользователя к приложению, и используется на протяжении жизни сессии.*Managed bean* обязательно должен быть Serializable. Контекст — сессия.

   **@ApplicationScoped** - инстанс создаётся один раз при обращении, и используется на протяжении жизни всего приложения. Не должен иметь состояния, а если имеет, то должен синхронизировать доступ, так как доступен для всех пользователей. Контекст — приложение.

   **@ViewScoped** - инстанс создаётся один раз при обращении к странице, и используется ровно столько, сколько пользователь находится на странице (включая ajax запросы). Контекст — страница.

   **@CustomScoped(value="#{someMap}")** - инстанс создаётся и сохраняется в Map. Программист сам управляет областью жизни

   **@NoneScoped** - инстанс создаётся, но не привязывается ни к одной области жизни. Полезно применять в *managed bean*'е, на который ссылаются другие *managed bean*'ы, имеющие область жизни

   **flash scope** - объекты внутри этой области жизни будут доступны для последующего запроса, после чего очищаются. Другими словами объект во *flash scope* переживёт *redirect*, после чего умрёт

7. Конфигурация JSF-приложений. Файл faces-config.xml. Класс FacesServlet.

​	faces-config.xml — конфигурационный файл JavaServer Faces, который должен находиться в 	директории WEB-INF проекта. В этом файле могут находиться настройки managed bean,	 конвертеры, валидаторы, локализация, навигации и другие настройки, связанные с JSF	

web.xml - стандартный конфигурационный файл, который представляет собой ядро Java web приложения

​	**FacesServlet**

​	\- Обрабатывает запросы с браузера.

​	\-	Формирует объекты-события и вызывает методы-слушатели.

8. Навигация в JSF-приложениях.

JSF включает в себя механизм навигации, аналогичный Struts. Он определяет связь между логическим признаком результата и следующим представлением. Реализуется экземплярами класса NavigationHandler.

 В некоторых случаях навигация не нужна. Навигация нужна для переходов между представлениями. Но многие библиотеки компонентов JSF содержат иерархические (древовидные) представления или представления с закладками.



Навигация осуществляется с помощью правил перехода. Добавление ссылки с домашней страницы на главную страницу

Ссылку можно добавить тремя различными способами:

**С помощью commandLink и обычного правила перехода**

**Правило перехода и элемент redirect** 

9. Доступ к БД из Java-приложений. Протокол JDBC, формирование запросов, работа с драйверами СУБД.

     1、DriverManager.getConnection(url);
     2、DriverManager.getConnection(url,info);
     3、DriverManager.getConnection(url,user,password);

   JDBC API是独立的数据库连接工业标准协议，这个数据库连接指的是Java编程语言和各种各样数据库的连接。JDBC API提供了通过SQL语言获取数据的一套可调用接口API。JDBC技术允许开发者在开发企业数据获取的应用中，使用JAVA语言来实现“一次写入，多地运行”的能力。

   就我的理解而言，JDBC是Java用来实现各种各样数据库连接的一套标准化接口协议。JDBC API定义了如何获取/修改数据库中的数据。由于不同的数据库操作数据的底层协议不同，因此不同的数据库厂商会提供对应的数据库驱动，比如mysql有提供给Java的驱动mysql-connection-java-xxx.jar, oracle有提供给Java的驱动ojdbcxx.jar，sqlserver有提供给Java的驱动sqljdbcxx.jar等等。当然，这些数据库厂商也有提供给其他编程语言的数据库连接驱动，比如mysql提供给c++的驱动mysql-connector-c++-8.0.13-macos10.14-x86-64bit.dmg等等。而这些驱动会实现JDBC API，将其转化成对应数据库协议，从而实现了对数据的操作。JDBC API
   1.Driver接口

   在操作数据库中的数据之前，先要加载对应的数据库驱动，如加载mysql对应的数据库驱动示例代码如下：Class.forName("com.mysql.jdbc.Driver");

   2.Connection接口

   加载完驱动后，就要从驱动管理器获取一个数据库的连接，通过这个连接完成数据库的数据操作，示例代码如下：Connection conn = DriverManager.getConnection("jdbc:mysql://host:port/database", "user", "password");

   该接口常用的方法有

    createStatement()：创建向数据库发送sql的statement对象。
    prepareStatement(sql) ：创建向数据库发送预编译sql的PrepareSatement对象。
    prepareCall(sql)：创建执行存储过程的callableStatement对象。
    setAutoCommit(boolean autoCommit)：设置事务是否自动提交。
    commit() ：在链接上提交事务
    rollback() ：在此链接上回滚事务
    close() : 关闭连接，释放资源
   3. Statement接口

   该接口主要用于SQL的执行，PreparedStatement和CallableStatement都继承该接口，这三种用于执行SQL语句的接口区别如下

   Statement 主要用于简单数据的查询，不带参数
   PreparedStatement用于带参数的查询，PreparedStatement对象比Statement对象的效率更高，并且可以防止SQL注入，所以一般的应用开发都是用此接口来实现SQL查询
   CallableStatement 用于存储过程的查询
   4. ResultSet接口

   主要是SQL查询结果的封装，用来实现数据的查询的处理。JDBC- интерфейс для sql-запросов. 

   

   10. Концепция ORM. Библиотеки ORM в приложениях на Java. Основные API. Интеграция ORM-провайдеров с драйверами JDBC.

   Работаете с голыми sql-запросами и оперируете таблицами, строками, колонками и значениями. Если результаты запроса нужно положить с объекты, то сами их туда распихиваете.
   ORM - интерфейс для мапинга классов на таблицы, строки, колонки и значения базы данных. Работаете с java-объектами, sql-запросы за вас формирует ORM. Другими словами, не задумываетесь (почти), каксоставить sql-запрос, вытащить из него данные и раскидать значения по своим классам.
   Предпочтительнее конечно работать с ORM, так как все за вас будет оптимизировано и закешировано. Конечно, нужно будет знать, не только как работает ваша база данных, но и как работает ваш ORM.